#include <iostream>
#include <algorithm>
#include <stack>
#include <queue>
using namespace std;
using ll = long long;
const int N = 300;

struct node                //结点类型
{
	char data;
	node* left, * right;
};
node* BuildExpTree(char* s, int n) {
	//将长度为n的后缀表达式s转换为表达式树，返回根结点指针
	stack<node*> stk;
	for (int i = 0; i < n; i++) {
		node* p = new node;
		p->data = s[i];
		if (s[i] >= '0' && s[i] <= '9') //操作数
			p->left = p->right = NULL;
		else { //运算符
			p->right = stk.top(); stk.pop();
			p->left = stk.top(); stk.pop();
		}
		stk.push(p);
	}
	return stk.top();
} 



stack<node*> EXP; //表达式结点栈
stack<char> OP; //运算符栈
void operation() {
	node* op = new node;
	op->data = OP.top(); OP.pop();
	op->right = EXP.top(); EXP.pop();
	op->left = EXP.top(); EXP.pop();
	EXP.push(op);
}
int rankx(char ch)         //判断级别
{
	if (ch == '^')return 3;
	else if (ch == '*' || ch == '/')return 2;
	else if (ch == '+' || ch == '-')return 1;
	else return 0;
}
node* build(char* s, int n) { //将长度为n的中缀表达式s转换为表达式树，返回根指针
	for (int i = 0; i < n; i++) {
		if (s[i] >= '0' && s[i] <= '9') { //假定操作数只有1位
			node* p = new node;
			p->data = s[i]; p->left = p->right = NULL;
			EXP.push(p);
		}
		else if (s[i] == '(') OP.push(s[i]);
		else if (s[i] == ')') {
			while (OP.top() != '(')
				operation();
			OP.pop();
		}
		else {
			while (!OP.empty() && OP.top() != '(' && rankx(s[i]) <= rankx(OP.top()))
				operation();
			OP.push(s[i]);
		}
	}
	while (!OP.empty()) operation();
	return EXP.top();
}
int Calc(node* t) { // t指向非空且合法的表达式树的根
	if (t->left == NULL && t->right == NULL) //若t是操作数
		return t->data - '0'; //假定操作数为0…9
	//若t是运算符
	int ans1 = Calc(t->left); //计算左子树的值
	int ans2 = Calc(t->right); //计算右子树的值
	char op = t->data; //假定仅有+-*/运算, 且除法除数肯定不为0
	if (op == '+') return ans1 + ans2;
	else if (op == '-') return ans1 - ans2;
	else if (op == '*') return ans1 * ans2;
	return ans1 / ans2;
}

int main()
{

	return 0;
}
