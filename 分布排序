#include <iostream>
#include <algorithm>
#include <stack>
#include <queue>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5 + 5;

//计数排序
void countingSort(int* R, int n, int m, int* cnt, int* B);
//基于计数排序的基数排序
void radixSort(int* R, int n, int d, int r);

int main()
{
	
}

//待排序的数组R包含n个整数，每个整数的值域为[0, m)。设置一个长度为 m 的数组cnt[]，初值为0。
//①扫描数组R求每个元素出现的次数存入cnt数组；
//②对cnt数组求前缀和, 使cnt[i]表示数组R中<=i的元素个数；
//③从右往左扫描R的每个元素K, 基于cnt[K]将K放入排序后的数组。
void countingSort(int* R, int n, int m, int* cnt, int* B)
{
	for (int i = 0; i < m; i++)cnt[i] = 0;
	for (int i = 1; i <= n; i++)cnt[R[i]]++;
	for (int i = 1; i < m; i++)cnt[i] += cnt[i - 1];
	for (int i = n; i >= 1; i--)B[cnt[R[i]]--] = R[i];
}
void radixSort(int* R, int n, int d, int r)  //d位
{
	int* B = new int[n + 1];
	int* cnt = new int[r];
	int* K = new int[n + 1];
	for (int k = 1, base = 1; k <= d; k++, base *= r)
	{
		for (int i = 0; i < r; i++)cnt[i] = 0;
		for (int i = 1; i <= n; i++)K[i] = (R[i] / base) % r; //取R[i]的第k位
		for (int i = 1; i <= n; i++)cnt[K[i]]++;
		for (int i = 1; i < r; i++)cnt[i] += cnt[i - 1];
		for (int i = n; i >= 1; i--)B[cnt[K[i]]--] = R[i];
		for (int i = 1; i <= n; i++)R[i] = B[i];
	}
	delete[]B; delete[]cnt; delete[]K;
}

