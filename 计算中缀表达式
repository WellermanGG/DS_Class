//若取出的字符是操作数，则加入后缀表达式
//若取出的字符是运算符：
//a.若为’(’，入栈；
//b.若为’)’，则依次把栈中的运算符加入后缀表达式，直到出现’(’，然后从栈中删除’(’；
//c.若为除了括号之外的其他运算符，当其优先级高于栈顶的运算符时，直接入栈；
//否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到遇到一个比它优先级低或遇到了一个左括号为止。

#include <iostream>
#include <algorithm>
#include <stack>
#include <queue>
#include <cstring>

using namespace std;
const int N = 1e5 + 5;
char a[1005];
stack<char> sym;            //符号栈
stack<int> num;             //数字栈

int rankx(char ch)
{
    if (ch == '^')return 3;
    else if (ch == '*' || ch == '/')return 2;
    else if (ch == '+' || ch == '-')return 1;
}

bool compute(char x)
{
    int x2 = num.top(); num.pop();
    int x1 = num.top(); num.pop();
    if (x == '+')
    {
        num.push(x1 + x2);
        return true;
    }
    else if (x == '-')
    {
        num.push(x1 - x2);
        return true;
    }
    else if (x == '*')
    {
        num.push(x1 * x2);
        return true;
    }
    else if (x == '/')
    {
        if (x2 != 0)
        {
            num.push(x1 / x2);
            return true;
        }
        else
        {
            return false;
        }
    }
    else if (x == '^')
    {
        int x3 = 1;
        for (int i = 1; i <= x2; i++)
        {
            x3 *= x1;
        }
        num.push(x3);
        return true;
    }
}

int main()
{
    start:
    while (cin >> a)
    {
        int len = strlen(a);
        for (int i = 0; i < len; i++)
        {
            char ch = a[i];
            if (ch == '(')
            {
                sym.push(ch);
            }
            else if (ch == ')')
            {
                while (sym.top() != '(')
                {
                    bool flag = compute(sym.top());            //计算
                    if (!flag)
                    {
                        cout << "INVALID" << endl;
                        while (!num.empty())num.pop();
                        while (!sym.empty())sym.pop();
                        //return 0;
                        goto start;
                    }
                    sym.pop();
                }
                sym.pop();            //弹出')'
            }
            else if (ch == '*' || ch == '/' || ch == '+' || ch == '-' || ch == '^')
            {
                while (1)
                {
                    if (sym.empty() || sym.top() == '(' || rankx(sym.top()) < rankx(ch))
                    {
                        sym.push(ch);
                        break;
                    }
                    else if (rankx(sym.top()) >= rankx(ch))
                    {
                        bool flag = compute(sym.top());            //计算
                        if (!flag)
                        {
                            cout << "INVALID" << endl;
                            while (!num.empty())num.pop();
                            while (!sym.empty())sym.pop();
                            //return 0;
                            goto start;
                        }
                        sym.pop();
                    }
                }
            }
            else
            {
                int x = a[i] - '0';
                while (a[i + 1] >= '0' && a[i + 1] <= '9')
                {
                    x = x * 10 + a[i + 1] - '0';
                    i++;             //重要
                }
                num.push(x);
            }
        }
        while (!sym.empty())    //将符号栈清空
        {
            bool flag = compute(sym.top());            //计算
            if (!flag)
            {
                cout << "INVALID" << endl;
                while (!num.empty())num.pop();
                while (!sym.empty())sym.pop();
                //return 0;
                goto start;
            }
            sym.pop();
        }
        cout << num.top() << endl;
        num.pop();
    }
    return 0;
}
