#include <iostream>
#include <algorithm>
#include <stack>
#include <queue>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5 + 5;
const int M = 10;

struct edge            //邻接表的边结点
{
    int veradj;
    int cost;
    edge* link;
    edge(int veradj = 0, int cost = 0, edge* link = NULL) :veradj(veradj), cost(cost), link(link) {}
};
struct vertex          //邻接表的顶点
{
    int vername;
    edge* adjacent;
    vertex(int vername = 0, edge* adjacent = NULL) :vername(vername), adjacent(adjacent) {}
};

int findMin(int* s, int* lowcost, int n)
{
    int v = -1, min = INF;
    for (int i = 1; i <= n; i++)
    {
        if (s[i] == 0 && lowcost[i] < min)
        {
            min = lowcost[i];
            v = i;
        }
    }
    return v;
}
int Prim(int G[M][M], int n, int u, int* lowcost, int* pre)
{
    //G是无向带权连通图的邻接矩阵
    int s[N] = { 0 }, sum = 0;
    for (int i = 1; i <= n; i++)
    {
        pre[i] = -1;
        lowcost[i] = (i == u) ? 0 : INF;
    }
    for (int i = 1; i <= n; i++)
    {
        int v = findMin(s, lowcost, n);
        if (v == -1)return sum;  //不存在跨边，图不连通
        s[v] = 1;
        sum += lowcost[v];
        for (int w = 1; w <= n; w++)
        {
            if (s[w] = 0 && G[v][w] < lowcost[w])
            {
                lowcost[w] = G[v][w];
                pre[w] = v;
            }
        }
    }
    return sum;
}
void outputMST(int* lowcost, int* pre, int n)
{
    //直接输出MST的边
    for (int v = 1; v <= n; v++)
    {
        if (pre[v] != -1)
        {
            cout << "edge:" << pre[v] << "-" << v << endl;
            cout << "weight:" << lowcost[v] << endl;
        }
    }
}
//void buildMST(vertex* head, int n, int* lowcost, int* pre)
//{
//    //构建MST的邻接表
//    for (int v = 1; v <= n; v++)
//    {
//        edge* p = head[v].adjacent;
//        head[v].adjacent=
//    }
//}

struct Edge
{
    int head;
    int tail;
    int weight;
}E[1010];
bool cmp(Edge& a, Edge& b)
{
    return a.weight < b.weight;
}
int Parent[N];
void Make_Set(int x) { //最终版本
    Parent[x] = 0; //根结点的秩为0
}
int Find(int x) { //最终版本
    if (Parent[x] == 0) return x; //x是根
    Parent[x] = Find(Parent[x]); //路径压缩
    return Parent[x];
}

void Union(int x, int y) { //最终版本
    int fx = Find(x), fy = Find(y);
    if (fx == fy) return; //x和y在同一棵树
    if (Parent[fx] < Parent[fy]) //fy秩小
        //存的是秩的相反数，实际上相当 rank[fx] > rank[fy] 
        Parent[fy] = fx; //fx作为fy的父结点
    else if (Parent[fx] > Parent[fy]) //fx秩小
        Parent[fx] = fy; //fy作为fx的父结点
    else { //fx和fy秩相等
        Parent[fx] = fy; //fy作为fx的父结点
        Parent[fy]--; //fy秩加1
    }
}
int Kruskal(Edge* E, int n, int e)
{
    for (int i = 1; i <= n; i++)Make_Set(i);
    sort(E, E + n, cmp);
    int sum = 0, k = 0;
    for (int i = 0; i < e; i++)
    {
        int u = E[i].head, v = E[i].tail, w = E[i].weight;
        if (Find(u) != Find(v))
        {
            cout << u << " " << v;
            k++;
            sum += w;
            Union(u, v);
        }
        if (k == n - 1)return sum;
    }
    return INF;
}

//求可及矩阵
void Warshall(int G[M][M], int n, bool R[M][M])
{
    for (int i = 1; i <= n; i++)//假定G是无权图
    {
        for (int j = 1; j <= n; j++)
        {
            R[i][j] = G[i][j];
        }
    }
    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                R[i][j] = R[i][j] || (R[i][k] && R[k][j]);
            }
        }
    }
}
//求强连通分量
int SCC(int G[M][M], int n, int* scc)
{
    bool R[M][M] = { {0} };
    for (int i = 1; i <= n; i++)scc[i] = 0;
    Warshall(G, n, R);
    int t = 0;
    for (int i = 1; i < n; i++)
    {
        if (scc[i] = 0)
        {
            scc[i] = ++t;
            for (int j = 1; j <= n; j++)
            {
                if (scc[j] == 0 && R[i][j] == 1 && R[j][i] == 1)
                {
                    scc[j] = t;
                }
            }
        }
    }
    return t;
}

int main()
{
    cout << "hello";
}
