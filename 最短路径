#include <iostream>
#include <algorithm>
#include <stack>
#include <queue>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5 + 5;

struct edge            //邻接表的边结点
{
    int veradj;
    int cost;
    edge* link;
    edge(int veradj = 0, int cost = 0, edge* link = NULL) :veradj(veradj), cost(cost), link(link) {}
};
struct vertex          //邻接表的顶点
{
    int vername;
    edge* adjacent;
    vertex(int vername = 0, edge* adjacent = NULL) :vername(vername), adjacent(adjacent) {}
};

void BFS(vertex* head, int n, int u, int* dist, int* pre)
{
    //基于BFS的无权图最短路径算法
    queue<int>q;
    for (int i = 1; i <= n; i++)
    {
        pre[i] = -1; dist[i] = INF;
    }
    dist[u] = 0; q.push(u);
    while (!q.empty())
    {
        int v = q.front(); q.pop();
        for (edge* p = head[v].adjacent; p != NULL; p = p->link)
        {
            int w = p->veradj;
            if (dist[w] == INF)
            {
                dist[w] = dist[v] + 1; pre[w] = v;
                q.push(w);
            }
        }
    }
}

//dist[i]：源点u到顶点i的最短距离，初始时dist[u]=0, dist[i]= 无穷
//pre[i]：u到i最短路径上i的前驱顶点编号，初始时pre[i]= -1
//s[i]：顶点i最是否已放入集合S中，初始时s[i]= 0
int findMin(int* s, int* dist, int n)
{
    int v = -1, min = INF;
    for (int i = 1; i <= n; i++)
    {
        if (s[i] == 0 && dist[i] < min)
        {
            min = dist[i];
            v = i;
        }
    }
    return v;
}
void Dijkstra(vertex* head, int n, int u, int* dist, int* pre, int* s)
{
    for (int i = 1; i <= n; i++)
    {
        pre[i] = -1; dist[i] = INF; s[i] = 0;
    }
    dist[u] = 0;
    for (int i = 1; i <= n; i++)
    {
        int v = findMin(s, dist, n);
        if (v == -1)return;//图不连通
        s[v] = 1;
        for (edge* p = head[v].adjacent; p != NULL; p = p->link)
        {
            int w = p->veradj;
            if (s[w] == 0 && dist[v] + p->cost < dist[w])
            {
                dist[w] = dist[v] + p->cost;
                pre[w] = v;
            }
        }
    }
}
void printPath1(int* pre, int s, int t)
{
    if (s == t)     //输出最短路
    {
        cout << s << " "; return;
    }
    printPath1(pre, s, pre[t]);
    cout << t << " ";
}

//D[i][j]：保存D(i, j)的值，即顶点i到顶点j的最短距离，初值等于邻接矩阵.
//path[i][j]：i到j最短路径上i的下一个顶点的编号.
const int  M= 10;
void Floyd(int G[M][M], int n, int D[M][M], int path[M][M])
{
    //适用于有向图，也适用于无向图，不允许存在负环
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            D[i][j] = G[i][j];
            path[i][j] = (i == j || G[i][j] == INF) ? -1 : j;
        }
    }
    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                if (D[i][k] + D[k][j] < D[i][j])
                {
                    D[i][j] = D[i][k] + D[k][j];
                    path[i][j] = path[i][k];
                }
            }
        }
    }
}
void printPath(int s, int t,int path[M][M])
{
    cout << s << " ";
    while (s != t)
    {
        s = path[s][t];
        cout << path[s][t] << " ";
    }
}
void Warshall(int G[M][M], int n, bool R[M][M])
{
    for (int i = 1; i <= n; i++)//假定G是无权图
    {
        for (int j = 1; j <= n; j++)
        {
            R[i][j] = G[i][j];
        }
    }
    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                R[i][j] = R[i][j] || (R[i][j] && R[k][j]);
            }
        }
    }
}

int main()
{
    cout << "hello";
}
