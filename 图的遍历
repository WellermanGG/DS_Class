#include <iostream>
#include <algorithm>
#include <stack>
#include <queue>
using namespace std;
const int N = 1e3 + 5;


struct edge            //邻接表的边结点
{
    int veradj;
    int cost;
    edge* link;
    edge(int veradj = 0, int cost = 0, edge* link = NULL) :veradj(veradj), cost(cost), link(link) {}
};
struct vertex          //邻接表的顶点
{
    int vername;
    edge* adjacent;
    vertex(int vername = 0, edge* adjacent = NULL) :vername(vername), adjacent(adjacent) {}
};


struct datax                        
{
    int a, b;
}Data[55];
bool cmp(datax x, datax y)
{
    if (x.a == y.a)
    {
        return x.b < y.b;
    }
    else
        return x.a < y.a;
}
int num[N];      
void createMap(int n, int e)           //建立图的邻接链表
{
    for (int i = 0; i < n; i++)
    {
        head[i].vername = i;
    }
    for (int i = 0; i < e; i++)
    {
        int a = Data[i].a, b = Data[i].b;
        head[a].vername = a;
        if (num[a] == 0)
        {
            num[a]++;
            edge* p = new edge;
            p->veradj = b; p->link = NULL;
            head[a].adjacent = p;
        }
        else
        {
            edge* p;
            for (p = head[a].adjacent; p->link != NULL; p = p->link);
            edge* q = new edge;
            q->veradj = b; q->link = NULL;
            p->link = q;
            num[a]++;
        }
    }
}


void getIndegree(vertex* head, int n, int* indegree)
{
    for (int i = 0; i < n; i++)indegree[i] = 0;
    for (int i = 0; i < n; i++)
    {
        for (edge* p = head[i].adjacent; p != NULL; p = p->link)
        {
            indegree[p->veradj]++;
        }
    }
}

vertex head[N];          //邻接表的顶点数组
int visited[N];
void visit(int v){}
void dfs(vertex* head, int v, int* visited)   
{
    //以v为起点进行深度优先搜索，visited数组初值为0
    visit(v); visited[v] = 1;
    for (edge* p = head[v].adjacent; p != NULL; p = p->link)
    {
        int k = p->veradj;
        if (visited[k] == 0)
            dfs(head, k, visited);
    }
}
void dfs2(vertex* head, int v, int* visited)          //非递归dfs
{
    stack<int>s;
    s.push(v);
    while (!s.empty())
    {
        v = s.top(); s.pop();
        if (visited[v] == 0)
        {
            visit(v); visited[v] = 1;
            for (edge* p = head[v].adjacent; p != NULL; p = p->link)
            {
                if (visited[p->veradj] == 0)s.push(p->veradj);
            }
        }
    }
}
void bfs(vertex* head, int v, int* visited)
{
    queue<int>q;
    visit(v); visited[v] = 1;
    q.push(v);
    while (!q.empty())
    {
        int v = q.front(); q.pop();
        for (edge* p = head[v].adjacent; p != NULL; p = p->link)
        {
            if (visited[p->veradj] == 0)
            {
                visit(p->veradj); visited[p->veradj] = 1;
                q.push(p->veradj);
            }
        }
    }
}

int main()
{
    return 0;
}
